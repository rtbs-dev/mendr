import numpy as np
from scipy.integrate import trapezoid,cumulative_trapezoid
# from sklearn.metrics import precision_recall_curve, fbeta_score
from scipy.linalg import sqrtm
from scipy.spatial.distance import cdist
from jaxtyping import Bool, jaxtyped, Float
from beartype import beartype
from dataclasses import dataclass, field

type PredProb = Float[np.ndarray, 'features']
type ProbThres = Float[np.ndarray, 'batch']
type PredThres = Bool[np.ndarray, 'batch features']

def gen_thres_vals(x:PredProb)-> ProbThres:
    return (x
     |> np.unique
     |> np.pad$(
         ?,  # implicit 0,1 thres endpts
         ((1,1)),
         constant_values=(0,1)
     )
    )



def _all_thres(x:PredProb, t:ProbThres)->PredThres:
    return np.less_equal.outer(t, x)


def _bool_contract(A:PredThres,B:PredThres) =(A*B).sum(axis=-1)
def _TP(actual:PredThres,pred:PredThres) = _bool_contract( pred, actual)
def _FP(actual:PredThres,pred:PredThres) = _bool_contract( pred,~actual)
def _FN(actual:PredThres,pred:PredThres) = _bool_contract(~pred, actual)
def _TN(actual:PredThres,pred:PredThres) = _bool_contract(~pred,~actual)

@dataclass
class Contingent:
    y_true: PredThres
    y_pred: PredThres

    TP:ProbThres = field(init=False)
    FP:ProbThres = field(init=False)
    FN:ProbThres = field(init=False)
    TN:ProbThres = field(init=False)

    PP:ProbThres = field(init=False)
    PN:ProbThres = field(init=False)
    P:ProbThres = field(init=False)
    N:ProbThres = field(init=False)


    PPV:ProbThres = field(init=False)
    NPV:ProbThres = field(init=False)
    TPR:ProbThres = field(init=False)
    TNR:ProbThres = field(init=False)

    def __post_init__(self):
        self.y_true = np.atleast_2d(self.y_true)
        self.y_pred = np.atleast_2d(self.y_pred)
        self.TP = _TP(self.y_true, self.y_pred)
        self.FP = _FP(self.y_true, self.y_pred)
        self.FN = _FN(self.y_true, self.y_pred)
        self.TN = _TN(self.y_true, self.y_pred)

        self.PP = self.TP + self.FP
        self.PN = self.FN + self.TN
        self.P = self.TP + self.FN
        self.N = self.FP + self.TN

        # self.PPV = np.divide(self.TP, self.PP, out=np.ones_like(self.TP), where=self.PP!=0.)
        self.PPV = np.ma.divide(self.TP, self.PP)
        self.NPV = np.ma.divide(self.TN, self.PN)
        self.TPR = np.ma.divide(self.TP, self.P)
        self.TNR = np.ma.divide(self.TN, self.N)


    @property
    def f_beta(self, beta)=(1+beta**2)*np.divide(
            self.PPV*self.TPR,
            beta**2*self.PPV + self.TPR
    )

    @property
    def f1(self)=self.f_beta(beta=1)

    @property
    def recall(self)=self.TPR.filled(0)

    @property
    def precision(self)=self.PPV.filled(1)


# def PPV(Yt:PredThres,Pt:PredThres) = TP/PP
# def NPV(Yt:PredThres,Pt:PredThres) = TN/PN
# def TPR(Yt:PredThres,Pt:PredThres) = TP/
# def TNR(Yt:PredThres,Pt:PredThres) = _bool_contract(~Pt,~Yt)

def f_beta(beta:float, Y:Contingent)-> ProbThres:
    top = (1+beta**2)*Y.PPV*Y.TPR
    bottom = beta**2*Y.PPV + Y.TPR

    return np.ma.divide(top, bottom).filled(0.)

def F1(Y:Contingent)->ProbThres = f_beta(1., Y)

def recall(Y:Contingent)->ProbThres = Y.TPR.filled(0.)

def precision(Y:Contingent)->ProbThres = Y.PPV.filled(1.)

def matt_corrcoef(Y:Contingent)->ProbThres:
    return 1-cdist(Y.y_pred, Y.y_true, "correlation")[:,0]

# def precision(y_true, y_pred):
#     TP,FP,TN,FN = _retrieval_square(y_true, p_pred)

def _wasserstein_gaussian(C1, C2):
    a = np.trace(C1+C2)
    sqrtC1 = sqrtm(C1)
    b = np.trace(sqrtm(sqrtC1@C2@sqrtC1))

    X = rw.to_array()
    # print(a,b)
    return a - 2*b

@jaxtyped(typechecker=beartype)
def bhattacharyya(a:PredProb,b:PredProb):
    """non-metric distance between distributions"""
    return np.sqrt(a*b).sum(axis=0)


@jaxtyped(typechecker=beartype)
def hellinger(a:PredProb,b:PredProb):
    """distance metric between binary distributions"""
    return np.sqrt(1-bhattacharyya(a,b))

@jaxtyped(typechecker=beartype)
def thres_expect(x_thres:Float[np.ndarray,'t'], score:Float[np.ndarray, 't'])->float:
    # return 0.5*thres_expect(stats.beta(0.5,0.5),x_thres, score)+0.5*thres_expect(stats.beta(2.5,1.7),x_thres,score)
    # return thres_expect(stats.beta(2.5,1.7), x_thres,score)
    return trapezoid(score, x=x_thres)
